//
//  AirchatApp.swift
//  Airchat
//
//  Created by Êù®È£û on 2025/6/18.
//

import SwiftUI
import AppKit
import Foundation
import KeyboardShortcuts

extension Notification.Name {
    static let windowStateChanged = Notification.Name("windowStateChanged")
}

extension NSBezierPath {
    var cgPath: CGPath {
        let path = CGMutablePath()
        var points = [CGPoint](repeating: .zero, count: 3)
        
        for i in 0..<elementCount {
            let type = element(at: i, associatedPoints: &points)
            switch type {
            case .moveTo:
                path.move(to: points[0])
            case .lineTo:
                path.addLine(to: points[0])
            case .curveTo:
                path.addCurve(to: points[2], control1: points[0], control2: points[1])
            case .quadraticCurveTo:
                path.addQuadCurve(to: points[1], control: points[0])
            case .cubicCurveTo:
                path.addCurve(to: points[2], control1: points[0], control2: points[1])
            case .closePath:
                path.closeSubpath()
            @unknown default:
                break
            }
        }
        
        return path
    }
}

class KeyablePanel: NSPanel {
    override var canBecomeKey: Bool {
        return true
    }
    
    override var canBecomeMain: Bool {
        return true
    }
}

@main
struct AirchatApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    
    static var appDelegate: AppDelegate? {
        NSApp.delegate as? AppDelegate
    }
    
    init() {
        // Ê≥®ÂÜåÂÖ®Â±ÄÂø´Êç∑ÈîÆÂõûË∞É
        KeyboardShortcuts.onKeyUp(for: .toggleWindow) {
            WindowManager.shared.toggleWindow()
        }
    }
    
    var body: some Scene {
        Settings {
            TabView {
                // Âø´Êç∑ÈîÆËÆæÁΩÆ
                VStack {
                    Text("Âø´Êç∑ÈîÆËÆæÁΩÆ")
                        .font(.headline)
                        .padding(.bottom, 10)
                    
                    KeyboardShortcuts.Recorder(
                        "Â±ïÂºÄ/ÊäòÂè†ÊµÆÁ™ó:",
                        name: .toggleWindow
                    )
                    
                    Text("ÈªòËÆ§Âø´Êç∑ÈîÆ: ‚å• + Space")
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .padding(.top, 5)
                }
                .frame(width: 300, height: 150)
                .padding()
                .tabItem {
                    Label("Âø´Êç∑ÈîÆ", systemImage: "keyboard")
                }
                
                // API Key ËÆæÁΩÆ
                APIKeySettingsView()
                    .tabItem {
                        Label("API Key", systemImage: "key.fill")
                    }
            }
            .frame(width: 400, height: 200)
        }
    }
}

final class AppDelegate: NSObject, NSApplicationDelegate {
    var statusItem: NSStatusItem!
    var panel: NSPanel?
    var menu: NSMenu!
    private let windowPositionKey = "AirchatWindowPosition"
    private var hasRestoredPosition = false
    private var isCollapsed = false
    
    // ÂÆö‰πâÊäòÂè†ÂíåÂ±ïÂºÄÁöÑÂ∞∫ÂØ∏
    private let collapsedSize = NSSize(width: 480, height: 64)  // ËæìÂÖ•Ê°ÜÂ∞∫ÂØ∏
    private let expandedSize = NSSize(width: 360, height: 520)
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        // Initialize API key securely
        KeychainHelper.shared.setInitialAPIKey()
        
        // Set WindowManager reference
        WindowManager.shared.appDelegate = self
        
        // Hide dock icon
        NSApp.setActivationPolicy(.accessory)
        
        // Create status bar item
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)
        
        // Set up the button
        if let button = statusItem.button {
            // üé® ‰ΩøÁî®ÁôΩËâ≤ÁâàÊú¨ÁöÑËèúÂçïÊ†èÂõæÊ†áÔºå‰∏éÂÖ∂‰ªñÂ∫îÁî®‰øùÊåÅ‰∏ÄËá¥
            if let image = NSImage(named: "MenuIconWhite") {
                // Ë∞ÉÊï¥ËèúÂçïÊ†èÂõæÊ†áÂ∞∫ÂØ∏‰∏∫ 24x24ÔºåÊõ¥Á¨¶ÂêàÁ≥ªÁªüÊ†áÂáÜ
                image.size = NSSize(width: 24, height: 24)
                // ËÆæÁΩÆ‰∏∫ template Ê®°ÂºèÔºåËÆ©Á≥ªÁªüËá™Âä®ÈÄÇÈÖçÊ∑±Ëâ≤/ÊµÖËâ≤Ê®°Âºè
                image.isTemplate = true
                button.image = image
            } else if let image = NSImage(named: "MenuIcon") {
                // Â§áÁî®ÊñπÊ°àÔºö‰ΩøÁî®ÂéüÂßãÂõæÊ†á
                image.size = NSSize(width: 24, height: 24)
                button.image = image
            } else {
                // ÊúÄÂêéÂ§áÁî®ÊñπÊ°àÔºö‰ΩøÁî®Á≥ªÁªüÂõæÊ†á
                button.image = NSImage(systemSymbolName: "bubble.left.and.bubble.right", accessibilityDescription: "Airchat")
            }
            button.action = #selector(toggleMenu)
            button.target = self
            button.sendAction(on: [.leftMouseUp, .rightMouseUp])
        }
        
        // Create menu
        let menu = NSMenu()
        menu.autoenablesItems = false
        
        let showChatItem = NSMenuItem(title: "ÊâìÂºÄËÅäÂ§©Á™óÂè£", action: #selector(showPanel), keyEquivalent: "")
        showChatItem.target = self
        menu.addItem(showChatItem)
        
        let resetPositionItem = NSMenuItem(title: "ÈáçÁΩÆÁ™óÂè£‰ΩçÁΩÆ", action: #selector(resetWindowPosition), keyEquivalent: "")
        resetPositionItem.target = self
        menu.addItem(resetPositionItem)
        
        menu.addItem(NSMenuItem.separator())
        
        let settingsItem = NSMenuItem(title: "ËÆæÁΩÆ...", action: #selector(openSettings), keyEquivalent: ",")
        settingsItem.target = self
        menu.addItem(settingsItem)
        
        menu.addItem(NSMenuItem.separator())
        
        let quitItem = NSMenuItem(title: "ÈÄÄÂá∫ Airchat", action: #selector(quitApp), keyEquivalent: "q")
        quitItem.target = self
        menu.addItem(quitItem)
        
        // Store menu but don't assign it yet
        self.menu = menu
        
        // Create the floating panel
        makePanel()
    }
    
    @objc func showPanel() {
        guard let panel = panel else { 
            print("Panel is nil!")
            return 
        }
        
        // Â¶ÇÊûúÊòØÈ¶ñÊ¨°ÊòæÁ§∫ÔºåÁ°Æ‰øùÁä∂ÊÄÅÂêåÊ≠•
        if panel.frame.size == .zero || (!hasRestoredPosition && isCollapsed) {
            // ÂàùÂßãÂåñ‰∏∫ÊäòÂè†Áä∂ÊÄÅ
            isCollapsed = true
            NotificationCenter.default.post(name: .windowStateChanged, object: nil, userInfo: ["isCollapsed": true])
        }
        
        // Get the main screen bounds
        guard let screen = NSScreen.main else {
            print("No main screen found!")
            return
        }
        let screenFrame = screen.visibleFrame
        
        // Try to restore saved position
        if let savedPosition = UserDefaults.standard.string(forKey: windowPositionKey),
           hasRestoredPosition {
            // Use saved position if available and we've restored at least once
            let components = savedPosition.split(separator: ",")
            if components.count == 2,
               let x = Double(components[0]),
               let y = Double(components[1]) {
                var savedFrame = NSRect(x: x, y: y, width: panel.frame.width, height: panel.frame.height)
                
                // Ensure the window is within screen bounds
                if !screenFrame.contains(savedFrame) {
                    print("Saved position is off-screen, resetting to default")
                    savedFrame = getDefaultWindowPosition()
                }
                
                panel.setFrame(savedFrame, display: true)
                print("Restored window position: \(savedFrame)")
            }
        } else {
            // First time or no saved position - position near status bar
            let defaultFrame = getDefaultWindowPosition()
            panel.setFrame(defaultFrame, display: true)
            hasRestoredPosition = true
            print("Using default window position: \(defaultFrame)")
        }
        
        panel.makeKeyAndOrderFront(nil)
        // ‰∏çË¶ÅËÆ©TextFieldÊàê‰∏∫Á¨¨‰∏ÄÂìçÂ∫îËÄÖÔºåÈÅøÂÖçÊòæÁ§∫ÁÑ¶ÁÇπÁéØ
        panel.makeFirstResponder(nil)
        NSApp.activate(ignoringOtherApps: true)
        
        // Apply mask after window is shown and sized
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.updateWindowMaskForCurrentState()
        }
    }
    
    private func getDefaultWindowPosition() -> NSRect {
        guard let screen = NSScreen.main else {
            return NSRect(x: 100, y: 100, width: isCollapsed ? 480 : 360, height: isCollapsed ? 64 : 520)
        }
        
        let screenFrame = screen.visibleFrame
        let windowSize = isCollapsed ? collapsedSize : expandedSize
        
        if isCollapsed {
            // ËæìÂÖ•Ê°ÜÊ®°ÂºèÔºöÂ±èÂπï‰∏≠Â§Æ
            return NSRect(
                x: screenFrame.midX - windowSize.width / 2,
                y: screenFrame.midY - windowSize.height / 2, // ÂûÇÁõ¥Â±Ö‰∏≠
                width: windowSize.width,
                height: windowSize.height
            )
        } else {
            // Â±ïÂºÄÊ®°ÂºèÔºöÂéüÊúâÈÄªËæë
            if let button = statusItem.button {
                let buttonRect = button.convert(button.bounds, to: nil)
                let screenRect = button.window?.convertToScreen(buttonRect) ?? .zero
                
                return NSRect(
                    x: screenRect.midX - 180,
                    y: screenRect.minY - 530,
                    width: 360,
                    height: 520
                )
            } else {
                // Fallback to center of screen
                return NSRect(
                    x: screenFrame.midX - 180,
                    y: screenFrame.midY - 260,
                    width: 360,
                    height: 520
                )
            }
        }
    }
    
    @objc private func toggleMenu() {
        guard let button = statusItem.button else { return }
        
        menu.popUp(positioning: nil, at: NSPoint(x: 0, y: button.bounds.height), in: button)
    }
    
    @objc private func quitApp() {
        // Ê∏ÖÁêÜÂä®ÁîªËµÑÊ∫ê
        stopAnimation()
        NSApplication.shared.terminate(nil)
    }
    
    deinit {
        // Á°Æ‰øùDisplayLinkË¢´Ê∏ÖÁêÜ
        stopAnimation()
        NotificationCenter.default.removeObserver(self)
    }
    
    @objc private func resetWindowPosition() {
        // Clear saved position
        UserDefaults.standard.removeObject(forKey: windowPositionKey)
        hasRestoredPosition = false
        
        // If window is open, reposition it
        if let panel = panel, panel.isVisible {
            let defaultFrame = getDefaultWindowPosition()
            panel.setFrame(defaultFrame, display: true, animate: true)
            print("Reset window position to default: \(defaultFrame)")
        }
    }
    
    @objc private func openSettings() {
        // ÁÆÄÂçïÁöÑÊñπÊ≥ïÔºöÁõ¥Êé•‰ΩøÁî® SwiftUI ÁöÑ Settings Âú∫ÊôØ
        DispatchQueue.main.async {
            // Êü•ÊâæÊòØÂê¶Â∑≤ÊúâËÆæÁΩÆÁ™óÂè£
            for window in NSApp.windows {
                if window.title.contains("ËÆæÁΩÆ") || window.title.contains("Settings") || window.identifier?.rawValue.contains("Settings") == true {
                    window.makeKeyAndOrderFront(nil)
                    NSApp.activate(ignoringOtherApps: true)
                    return
                }
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåÂ∞ùËØïÈÄöËøáÈîÆÁõòÂø´Êç∑ÈîÆÊâìÂºÄ
            let event = NSEvent.keyEvent(with: .keyDown, location: NSPoint.zero, modifierFlags: [.command], timestamp: 0, windowNumber: 0, context: nil, characters: ",", charactersIgnoringModifiers: ",", isARepeat: false, keyCode: 43)
            if let event = event {
                NSApp.postEvent(event, atStart: false)
            }
        }
    }
    
    
    // ‰ºòÂåñÁöÑÁ™óÂè£Âä®ÁîªÁ≥ªÁªü
    private var animationTimer: Timer?
    private var animationStartTime: CFTimeInterval = 0
    private var animationDuration: CFTimeInterval = 0.2
    private var startFrame = NSRect.zero
    private var targetFrame = NSRect.zero
    private var isAnimating = false
    
    func toggleWindowState(collapsed: Bool) {
        guard let panel = panel else { return }
        
        // Â¶ÇÊûúÂ∑≤ÁªèÊòØÁõÆÊ†áÁä∂ÊÄÅÔºåÁõ¥Êé•ËøîÂõû
        if isCollapsed == collapsed {
            print("Á™óÂè£Â∑≤ÁªèÊòØÁõÆÊ†áÁä∂ÊÄÅ: \(collapsed ? "ÊäòÂè†" : "Â±ïÂºÄ")")
            return
        }
        
        // Â¶ÇÊûúÊ≠£Âú®Âä®ÁîªÔºåÂÖàÂÅúÊ≠¢
        stopAnimation()
        
        isCollapsed = collapsed
        let targetSize = collapsed ? collapsedSize : expandedSize
        
        // ËÆ°ÁÆóÂä®ÁîªÂèÇÊï∞
        startFrame = panel.frame
        targetFrame = startFrame
        
        // ‰ºòÂåñÂä®ÁîªÈÄªËæëÔºö‰øùÊåÅÂ∫ïÈÉ®‰ΩçÁΩÆÂõ∫ÂÆöÔºåÂêë‰∏äÂ±ïÂºÄ
        targetFrame.size = targetSize
        targetFrame.origin.x = startFrame.midX - targetSize.width / 2  // Ê∞¥Âπ≥Â±Ö‰∏≠
        // ‰øùÊåÅÂ∫ïÈÉ®‰ΩçÁΩÆÂõ∫ÂÆöÔºöÊñ∞Á™óÂè£Â∫ïÈÉ® = ÂéüÁ™óÂè£Â∫ïÈÉ®
        targetFrame.origin.y = startFrame.origin.y + startFrame.height - targetSize.height
        
        // üîß ‰øÆÂ§çÔºöÂç≥Êó∂ÂàáÊç¢SwiftUIÂÜÖÂÆπÔºå‰ΩøÁî®Á∫øÊÄßÂä®ÁîªÂêåÊ≠•
        // Á´ãÂç≥ÈÄöÁü•ÂÜÖÂÆπÂàáÊç¢Ôºå‰æùÈù†Êõ¥Âø´ÁöÑÁ∫øÊÄßÂä®ÁîªÈÅøÂÖçÈáçÂè†
        NotificationCenter.default.post(name: .windowStateChanged, object: nil, userInfo: ["isCollapsed": collapsed])
        
        // Á´ãÂç≥ÂºÄÂßãÁ™óÂè£Â∞∫ÂØ∏Âä®Áîª
        startTimerAnimation()
    }
    
    private func startTimerAnimation() {
        guard let panel = panel else { return }
        
        isAnimating = true
        animationStartTime = CACurrentMediaTime()
        
        // ÂºÄÂßãÊÄßËÉΩÁõëÊµã
        AnimationPerformanceMonitor.shared.startMonitoring()
        
        // ÂàõÂª∫Ë∂ÖÈ´òÁ≤æÂ∫¶ÂÆöÊó∂Âô®Ôºà120fps = 8.33msÈó¥ÈöîÔºâ- Êõ¥‰∏ùÊªëÁöÑÂä®Áîª
        animationTimer = Timer.scheduledTimer(withTimeInterval: 1.0/120.0, repeats: true) { [weak self] _ in
            self?.updateAnimation()
        }
        
        // ËÆæÁΩÆÂÆöÊó∂Âô®‰ºòÂÖàÁ∫ß
        RunLoop.current.add(animationTimer!, forMode: .common)
        
        // ‰øùÊåÅVisualEffectViewÂÖºÂÆπÊÄß
        panel.displaysWhenScreenProfileChanges = false
    }
    
    private func updateAnimation() {
        guard let panel = panel, isAnimating else {
            stopAnimation()
            return
        }

        // ËÆ∞ÂΩïÂ∏ßÊÄßËÉΩ
        AnimationPerformanceMonitor.shared.recordFrame()

        let currentTime = CACurrentMediaTime()
        let elapsed = currentTime - animationStartTime
        let progress = min(elapsed / animationDuration, 1.0)

        // ‰ΩøÁî®Âç∑Â∏òÈó®ÊïàÊûúÁöÑÁºìÂä®ÂáΩÊï∞ - Êõ¥Êé•ËøëÁ∫øÊÄß‰ΩÜÁ®çÂæÆÊüîÂíå
        let easedProgress = easeInOutSine(progress)

        // ËÆ°ÁÆóÊèíÂÄºframe - ‰ΩøÁî®È´òÁ≤æÂ∫¶ÊèíÂÄºÁ°Æ‰øù‰∏ùÊªëËøáÊ∏°
        let currentFrame = NSRect(
            x: smoothLerp(startFrame.origin.x, targetFrame.origin.x, easedProgress),
            y: smoothLerp(startFrame.origin.y, targetFrame.origin.y, easedProgress),
            width: smoothLerp(startFrame.width, targetFrame.width, easedProgress),
            height: smoothLerp(startFrame.height, targetFrame.height, easedProgress)
        )

        // ËÆæÁΩÆframeÂπ∂‰øùÊåÅËßÜËßâÊïàÊûú
        panel.setFrame(currentFrame, display: true, animate: false)

        // üîß Âç∑Â∏òÈó®ÊïàÊûúÔºöÊõ¥È¢ëÁπÅÁöÑÈÅÆÁΩ©Êõ¥Êñ∞Á°Æ‰øùÂπ≥Êªë
        let frameCount = Int(progress * 60) // Âü∫‰∫é60fpsËÆ°ÁÆóÂ∏ßÊï∞
        if frameCount % 2 == 0 || progress >= 1.0 { // ÊØè2Â∏ßÊõ¥Êñ∞‰∏ÄÊ¨°Ôºå‰øùÊåÅÊµÅÁïÖ
            updateWindowMaskForCurrentFrame(currentFrame)
        }

        // Âä®ÁîªÂÆåÊàê
        if progress >= 1.0 {
            stopAnimation()
            // ÊúÄÂêéÁ°Æ‰øùÈÅÆÁΩ©Ê≠£Á°Æ
            updateWindowMaskForCurrentState()
        }
    }
    
    private func stopAnimation() {
        animationTimer?.invalidate()
        animationTimer = nil
        isAnimating = false
        
        // ÂÅúÊ≠¢ÊÄßËÉΩÁõëÊµã
        AnimationPerformanceMonitor.shared.stopMonitoring()
        
        // ÊÅ¢Â§çÊ≠£Â∏∏ÁöÑÁ™óÂè£ËÆæÁΩÆ
        panel?.displaysWhenScreenProfileChanges = true
    }
    
    // Âç∑Â∏òÈó®ÊïàÊûúÁöÑÁºìÂä®ÂáΩÊï∞ - Êé•ËøëÁ∫øÊÄß‰ΩÜÊõ¥ÊüîÂíå
    private func easeInOutSine(_ t: Double) -> Double {
        return -(cos(.pi * t) - 1) / 2
    }
    
    // Êõ¥‰∏ùÊªëÁöÑÁºìÂä®ÂáΩÊï∞ - Ê®°ÊãüËá™ÁÑ∂ÁöÑËøáÊ∏°ÊïàÊûú
    private func easeInOutCubic(_ t: Double) -> Double {
        if t < 0.5 {
            return 4 * t * t * t
        } else {
            let p = 2 * t - 2
            return 1 + p * p * p / 2
        }
    }
    
    // Êõ¥‰∏ùÊªëÁöÑÁºìÂä®ÂáΩÊï∞ - Ê®°ÊãüÁ™óÂ∏ò‰∏ãÊãâÁöÑËá™ÁÑ∂Áâ©ÁêÜÊïàÊûú
    private func easeOutQuart(_ t: Double) -> Double {
        let p = t - 1
        return 1 - p * p * p * p
    }

    // Â§áÁî®ÁöÑÊõ¥Âπ≥ÊªëÁºìÂä®ÂáΩÊï∞
    private func easeInOutQuint(_ t: Double) -> Double {
        if t < 0.5 {
            return 16 * t * t * t * t * t
        } else {
            let p = 2 * t - 2
            return 1 + p * p * p * p * p / 2
        }
    }
    
    // È´òÁ≤æÂ∫¶Âπ≥ÊªëÊèíÂÄº - ÂáèÂ∞ëÂä®ÁîªÊäñÂä®
    private func smoothLerp(_ start: Double, _ end: Double, _ progress: Double) -> Double {
        // ‰ΩøÁî®Êõ¥È´òÁ≤æÂ∫¶ÁöÑËÆ°ÁÆóÔºåÈÅøÂÖçÊµÆÁÇπÊï∞Á≤æÂ∫¶ÈóÆÈ¢ò
        let diff = end - start
        let result = start + diff * progress

        // ÂØπ‰∫éÈùûÂ∏∏Â∞èÁöÑÂèòÂåñÔºåÁõ¥Êé•ËøîÂõûÁõÆÊ†áÂÄºÈÅøÂÖçÊäñÂä®
        if abs(diff) < 0.01 && progress > 0.95 {
            return end
        }

        return result
    }

    // Ê†áÂáÜÁ∫øÊÄßÊèíÂÄºÔºàÂ§áÁî®Ôºâ
    private func lerp(_ start: Double, _ end: Double, _ progress: Double) -> Double {
        return start + (end - start) * progress
    }
    
    private func makePanel() {
        // ÈªòËÆ§‰ª•ÊäòÂè†Áä∂ÊÄÅÔºàËæìÂÖ•Ê°ÜÔºâÂºÄÂßã
        isCollapsed = true
        panel = KeyablePanel(
            contentRect: NSRect(x: 0, y: 0, width: collapsedSize.width, height: collapsedSize.height),
            styleMask: [.borderless, .nonactivatingPanel],
            backing: .buffered,
            defer: true
        )
        
        panel?.level = .floating
        panel?.isMovableByWindowBackground = true
        // Floato solution: ÂÆåÂÖ®ÈÄèÊòéÁöÑÁ™óÂè£ËÉåÊôØ
        panel?.backgroundColor = .clear
        panel?.isOpaque = false
        panel?.hasShadow = false
        panel?.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]
        
        // Á°Æ‰øùÁ™óÂè£ÂèØ‰ª•Êé•ÂèóÈº†Ê†á‰∫ã‰ª∂ÂíåÈîÆÁõòËæìÂÖ•
        panel?.acceptsMouseMovedEvents = true
        panel?.ignoresMouseEvents = false
        
        // Set up the SwiftUI content
        let contentView = NSHostingView(rootView: ChatWindow())
        contentView.translatesAutoresizingMaskIntoConstraints = false
        
        // Á°Æ‰øùVisualEffectViewËÉΩÊ≠£Â∏∏Â∑•‰Ωú
        contentView.wantsLayer = true
        contentView.layer?.backgroundColor = NSColor.clear.cgColor
        contentView.layer?.isOpaque = false
        
        panel?.contentView = contentView
        
        // Floato solution: Apply window-level corner mask and observe frame changes
        applyWindowMask()
        observeWindowFrameChanges()
        
        // Ensure no background drawing
        panel?.hidesOnDeactivate = false
        
        // ÁõëÂê¨Â∫îÁî®ÊøÄÊ¥ª‰∫ã‰ª∂ÔºåÁ°Æ‰øùÁ™óÂè£ÂßãÁªàÂú®ÂâçÈù¢
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(applicationDidBecomeActive),
            name: NSApplication.didBecomeActiveNotification,
            object: nil
        )
        
        // ÁõëÂê¨ÂÖ∂‰ªñÂ∫îÁî®ÊøÄÊ¥ª‰∫ã‰ª∂
        NSWorkspace.shared.notificationCenter.addObserver(
            self,
            selector: #selector(otherApplicationDidActivate),
            name: NSWorkspace.didActivateApplicationNotification,
            object: nil
        )
    }
    
    func applicationShouldHandleReopen(_ sender: NSApplication, hasVisibleWindows flag: Bool) -> Bool {
        if !flag {
            showPanel()
        }
        return true
    }
    
    @objc private func applicationDidBecomeActive() {
        bringPanelToFront()
    }
    
    @objc private func otherApplicationDidActivate() {
        // ÂΩìÂÖ∂‰ªñÂ∫îÁî®ÊøÄÊ¥ªÊó∂ÔºåÁ°Æ‰øùÊàë‰ª¨ÁöÑÈù¢Êùø‰ªçÁÑ∂Âú®ÂâçÈù¢
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            self.bringPanelToFront()
        }
    }
    
    private func bringPanelToFront() {
        guard let panel = panel, panel.isVisible else { return }
        panel.level = .floating
        panel.orderFrontRegardless()
        
        // Á°Æ‰øùÁ™óÂè£ÂèØ‰ª•Êé•Âèó‰∫ã‰ª∂
        panel.makeKeyAndOrderFront(nil)
        // ‰∏çË¶ÅËÆ©TextFieldÊàê‰∏∫Á¨¨‰∏ÄÂìçÂ∫îËÄÖ
        panel.makeFirstResponder(nil)
    }
    
    // Observe window frame changes to update mask and save position
    private func observeWindowFrameChanges() {
        guard let panel = panel else { return }
        
        NotificationCenter.default.addObserver(
            forName: NSWindow.didResizeNotification,
            object: panel,
            queue: .main
        ) { _ in
            self.updateWindowMaskForCurrentState()
        }
        
        // Save position when window moves
        NotificationCenter.default.addObserver(
            forName: NSWindow.didMoveNotification,
            object: panel,
            queue: .main
        ) { _ in
            self.saveWindowPosition()
        }
    }
    
    func saveWindowPosition() {
        guard let panel = panel else { return }
        let position = "\(panel.frame.origin.x),\(panel.frame.origin.y)"
        UserDefaults.standard.set(position, forKey: windowPositionKey)
    }
    
    // Update mask based on current window size
    private func updateWindowMaskForCurrentState() {
        guard let panel = panel else { return }
        updateWindowMaskForCurrentFrame(panel.frame)
    }

    // üîß Êñ∞Â¢ûÔºöÊ†πÊçÆÂΩìÂâçframeÂÆûÊó∂Êõ¥Êñ∞ÈÅÆÁΩ©
    private func updateWindowMaskForCurrentFrame(_ currentFrame: NSRect) {
        // Determine if collapsed based on window size
        // Collapsed: 480x64, Expanded: 360x520

        // Âä®ÊÄÅËÆ°ÁÆóÂúÜËßíÂçäÂæÑÔºåÂú®Âä®ÁîªËøáÁ®ã‰∏≠Âπ≥ÊªëËøáÊ∏°
        let collapsedRadius: CGFloat = 32
        let expandedRadius: CGFloat = 20

        let cornerRadius: CGFloat
        if currentFrame.width >= 480 {
            // ÊäòÂè†Áä∂ÊÄÅÊàñÊé•ËøëÊäòÂè†Áä∂ÊÄÅ
            cornerRadius = collapsedRadius
        } else if currentFrame.width <= 360 {
            // Â±ïÂºÄÁä∂ÊÄÅÊàñÊé•ËøëÂ±ïÂºÄÁä∂ÊÄÅ
            cornerRadius = expandedRadius
        } else {
            // Âä®ÁîªËøáÁ®ã‰∏≠ÔºåÊ†πÊçÆÂÆΩÂ∫¶ÊèíÂÄºËÆ°ÁÆóÂúÜËßí
            let progress = (currentFrame.width - 360) / (480 - 360)
            cornerRadius = expandedRadius + (collapsedRadius - expandedRadius) * progress
        }

        applyWindowMask(cornerRadius: cornerRadius)
    }
    
    // ‰ºòÂåñÁöÑÁ™óÂè£maskÂ∫îÁî® - ÂáèÂ∞ëÈáçÂª∫È¢ëÁéáÂíåËßÜËßâÊäñÂä®
    private func applyWindowMask(cornerRadius: CGFloat = 20) {
        guard let panel = panel, let contentView = panel.contentView else { return }

        // Âè™ÊúâÂú®ÈúÄË¶ÅÊó∂ÊâçÂêØÁî®layer
        if !contentView.wantsLayer {
            contentView.wantsLayer = true
        }

        let windowFrame = contentView.bounds
        guard windowFrame.width > 0 && windowFrame.height > 0 else { return }

        // üîß ‰ºòÂåñÔºöÂ§çÁî®Áé∞ÊúâÁöÑmask layerÔºåÂè™Êõ¥Êñ∞pathÔºåÂπ∂Ê∑ªÂä†Âπ≥ÊªëËøáÊ∏°
        if let layer = contentView.layer {
            let path = NSBezierPath(roundedRect: windowFrame, xRadius: cornerRadius, yRadius: cornerRadius)

            if let existingMask = layer.mask as? CAShapeLayer {
                // üîß ÂÖ≥ÈîÆ‰øÆÂ§çÔºö‰ΩøÁî®ÈöêÂºèÂä®ÁîªËÆ©ÈÅÆÁΩ©ÂèòÂåñÊõ¥Âπ≥Êªë
                CATransaction.begin()
                CATransaction.setDisableActions(false) // ÂêØÁî®ÈöêÂºèÂä®Áîª
                CATransaction.setAnimationDuration(0.1) // Áü≠ÊöÇÁöÑËøáÊ∏°Âä®Áîª
                CATransaction.setAnimationTimingFunction(CAMediaTimingFunction(name: .easeOut))

                // Â§çÁî®Áé∞ÊúâÁöÑmask layerÔºåÂè™Êõ¥Êñ∞path
                existingMask.path = path.cgPath

                CATransaction.commit()
            } else {
                // È¶ñÊ¨°ÂàõÂª∫mask layer
                let shapeLayer = CAShapeLayer()
                shapeLayer.path = path.cgPath
                shapeLayer.fillRule = .evenOdd

                layer.mask = shapeLayer
                layer.masksToBounds = true
                layer.backgroundColor = NSColor.clear.cgColor
                layer.isOpaque = false
            }
        }
    }
}
